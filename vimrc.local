" vim: set foldmarker={{{,}}} foldlevel=0 foldmethod=marker:

"
" local settings Copyright (c) 2015 Stefan Martin
"
" WEBDEVICONS {{{
let g:webdevicons_enable = 1
let g:webdevicons_enable_airline_tabline = 1
let g:webdevicons_enable_airline_statusline = 1
" }}}

" USEFULL SHORTCUTS {{{
if isdirectory(expand("~/.vim/bundle/vim-signify/"))
    nmap <leader>gj <plug>(signify-next-hunk)
    nmap <leader>gk <plug>(signify-prev-hunk)
endif

" }}}

" CSCOPE {{{
if has("cscope")
    " use both cscope and ctag for 'ctrl-]', ':ta', and 'vim -t'
    set nocscopetag " switch cscope of until it generates correct symbols for the 32 and 64bit platforms

    " 1 = check ctags for definition of a symbol before checking cscope
    " 0 = reverse
    set csto=1

    " add any cscope database in current directory
    " note: this is better than the autoload_cscope plugin because it allows 'vim -t {tag}' from the command line
    if filereadable("cscope.out")
        cs add cscope.out
        " else search up a few directories
    elseif filereadable("../cscope.out")
        cs add ../cscope.out
    elseif filereadable("../../cscope.out")
        cs add ../../cscope.out
    elseif filereadable("../../../cscope.out")
        cs add ../../../cscope.out
    elseif filereadable("../../../../cscope.out")
        cs add ../../../../cscope.out
    elseif filereadable("../../../../../cscope.out")
        cs add ../../../../../cscope.out
    elseif filereadable("../../../../../../cscope.out")
        cs add ../../../../../../cscope.out
    elseif filereadable("../../../../../../../cscope.out")
        cs add ../../../../../../../cscope.out
    elseif filereadable("../../../../../../../../cscope.out")
        cs add ../../../../../../../../cscope.out
    elseif filereadable("../../../../../../../../../cscope.out")
        cs add ../../../../../../../../../cscope.out
    elseif filereadable("../../../../../../../../../../cscope.out")
        cs add ../../../../../../../../../../cscope.out
        " else add database pointed to by environment
    elseif $CSCOPE_DB != ""
        cs add $CSCOPE_DB
    endif

    " The following maps all invoke one of the following cscope search types:
    " (note: <C-@> = <C-Space> = Ctrl+Space
    "
    "   's'   symbol: find all references to the token under cursor
    "   'g'   global: find global definition(s) of the token under cursor
    "   'c'   calls:  find all calls to the function name under cursor
    "   't'   text:   find all instances of the text under cursor
    "   'e'   egrep:  egrep search for the word under cursor
    "   'f'   file:   open the filename under cursor
    "   'i'   includes: find files that include the filename under cursor
    "   'd'   called: find functions that function under cursor calls
    nmap <C-@>s :cs find s <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@>g :cs find g <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@>c :cs find c <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@>t :cs find t <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@>e :cs find e <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@>f :cs find f <C-R>=expand("<cfile>")<CR><CR>
    nmap <C-@>i :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
    nmap <C-@>d :cs find d <C-R>=expand("<cword>")<CR><CR>

    " Ctrl+space+space will open cscope results in vertically split window
    nmap <C-@><C-@>s :vert scs find s <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@><C-@>g :vert scs find g <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@><C-@>c :vert scs find c <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@><C-@>t :vert scs find t <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@><C-@>e :vert scs find e <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@><C-@>i :vert scs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
    nmap <C-@><C-@>d :vert scs find d <C-R>=expand("<cword>")<CR><CR>
endif
" }}}

" COLORSCHEME:solarized {{{

if filereadable(expand("~/.vim/bundle/vim-colors-solarized/colors/solarized.vi"))
    let g:solarized_termcolors=256
    let g:solarized_termtrans=1
    let g:solarized_contrast="normal"
    let g:solarized_visibility="normal"
    "set background=light
    color solarized
endif
" }}}

" COLORSCHEME {{{
if !has('gui_running')
    colorscheme smyck
    hi ColorColumn ctermbg=LightBlue
    " COLORSETTING OVERRIDE {{{
    set t_Co=256
    "hi CursorLineNr term=bold ctermfg=Yellow gui=bold guifg=Yellow
    " execute set colorcolumn= . join(range(120,335), ',')
    " call matchadd('ColorColumn', '\%81v', 100)
    " }}}
    hi Folded ctermbg=237 ctermfg=7
endif
" }}}

" CTRLP PLUGIN {{{
if isdirectory(expand("~/.vim/bundle/ctrlp.vim/"))
    let g:ctrlp_clear_cache_on_exit = 0
    let g:ctrlp_show_hidden         = 1
    let g:ctrlp_follow_sym_links    = 1
    let g:ctrlp_reuse_window        = 'startify'
    " let g:ctrlp_map                 = '<C-p>'
    let g:ctrlp_cmd                 = 'CtrlP'
    let g:ctrlp_use_caching         = 1
    let g:ctrlp_cache_dir           = $HOME . '/.cache/ctrlp'
    let g:ctrlp_by_mru              = 1
    let g:ctrlp_working_path_mode   = 'ra'
    let g:ctrlp_max_height          = 25
    let g:ctrlp_max_files           = 0
    let g:ctrlp_max_depth           = 80
    " let g:ctrlp_extension           = ['buffertag', 'tag', 'line', 'dir']
    " let g:ctrlp_match_window        = 'top,order:ttb,min:1,max:30,results:12'
    let g:ctrlp_match_func          = { 'match': 'pymatcher#PyMatch' }
    " let g:ctrlp_use_vcs_ls            = 1

    if (has("gui_macvim"))
        nnoremap <silent> <D-p> :CtrlP<CR>
        nnoremap <silent> <D-r> :CtrlPFunky<CR>
        nnoremap <silent> <D-e> :CtrlPMRU<CR>
        nnoremap <silent> <D-t> :CtrlPBuffer<CR>
        nnoremap <silent> <leader>l :CtrlPMRU<CR>
        nnoremap <silent> <leader>b :CtrlPBuffer<CR>
    else
        nnoremap <silent> <leader>l :CtrlPMRU<CR>
        nnoremap <silent> <leader>b :CtrlPBuffer<CR>
    endif

    nnoremap <silent> <leader>ct :CtrlPBufTag<CR>
    nnoremap <silent> <leader>T :CtrlPTag<CR>
    nnoremap <silent> <leader>cl :CtrlPLine<CR>

    " let g:ctrlp_custom_ignore = {
    "     \ 'dir':  'Users/|\.git$\|\.hg$\|\.svn$|vendor|node_modules',
    "     \ 'file': '\.exe$\|\.so$\|\.dll$\|\.pyc$'
    "  \}

    " On Windows use "dir" as fallback command.
    " if WINDOWS()
    "     let s:ctrlp_fallback = 'dir %s /-n /b /s /a-d'
    " elseif executable('ag')
    "     let s:ctrlp_fallback = 'ag %s --nocolor -l -g ""'
    " elseif executable('ack-grep')
    "     let s:ctrlp_fallback = 'ack-grep %s --nocolor -f'
    " elseif executable('ack')
    "     let s:ctrlp_fallback = 'ack %s --nocolor -f'
    " else
    "     let s:ctrlp_fallback = 'find %s -type f'
    " endif
    "
    " let g:ctrlp_user_command = 'ag %s -i --nocolor --nogroup --hidden
    "     \ --ignore .git
    "     \ --ignore .svn
    "     \ --ignore node_modules
    "     \ --ignore vendor
    "     \ --ignore components
    "     \ --ignore .DS_Store
    "     \ -g ""'

    let g:ctrlp_user_command = {
        \ 'types': {
        \ 1: ['.svn', 'svn list %s --recursive --include-externals'],
        \ },
        \ 'fallback': 'ag %s -i --nocolor --nogroup --hidden -g ""'
        \ }

    "let g:ctrlp_user_command = 'svn ls % --recursive --include-externals'

    if isdirectory(expand("~/.vim/bundle/ctrlp-funky/"))
        " CtrlP extensions
        let g:ctrlp_funky_syntax_highlight = 1
        " let g:ctrlp_extensions = ['funky']

        nmap <leader>fU :execute 'CtrlPFunky ' . expand('<cword>')<CR>
        nmap <leader>fu :CtrlPFunky<CR>
        if has('gui_running')
            nmap <silent> <D-R> :CtrlPFunky<CR>
        endif
    endif
endif
" }}}

" AG PLUGIN {{{
" https://github.com/rking/ag.vim.git bundle/ag
let g:ag_working_path_mode="r"
let g:ag_prg="ag --vimgrep --ignore-case"

nnoremap <leader>a :Ag!<SPACE>
if executable("ag")
    " set grepprg=ag\ --nogroup\ --nocolor\ --column
    set grepprg=ag\ --vimgrep\ $*
    set grepformat=%f:%l:%c:%m
    command! -nargs=+ -complete=file_in_path -bar Grep silent! grep! <args>|cwindow|redraw!

    nnoremap K :silent! grep! "\b<C-r><C-w>\b"<CR>:cwindow<CR>:redraw!<CR>
endif
" }}}

" SYNTASTIC PLUGIN {{{
" git clone https://github.com/scrooloose/syntastic.git
if isdirectory(expand("~/.vim/bundle/syntastic"))
    let g:syntastic_mode_map = {'mode':'passive', 'active_file_types':[], 'passive_file_types':[]}
    let g:syntastic_php_checkers = ['php', 'phpcs', 'phpmd']
    let g:syntastic_javascript_checkers = ['eslint']
    "set statusline+=%#warningmsg#
    "set statusline+=%{SyntasticStatuslineFlag()}
    "set statusline+=%*

    let g:syntastic_php_phpcs_args           = "--standard=Zend"
    let g:syntastic_always_populate_loc_list = 1
    let g:syntastic_aggregate_errors         = 1
    "let g:syntastic_auto_loc_list            = 0
    let g:syntastic_check_on_open            = 1
    let g:syntastic_check_on_wq              = 0
    let g:syntastic_auto_jump                = 1
    let g:syntastic_error_symbol             = "✗"
    let g:syntastic_style_error_symbol       = "✗"
    let g:syntastic_warning_symbol           = "⚠"
    let g:syntastic_style_warning_symbol     = "⚠"

    nnoremap <leader>E :SyntasticCheck<CR> :SyntasticToggleMode<CR>
endif
" }}}

" VIM-PHPFMT PLUGIN {{{
" git clone https://github.com/dericofilho/vim-phpfmt.git
let g:phpfmt_on_save = 0
let g:phpfmt_psr2=1
" disable it until it works correctly
let g:phpfmt_enable_default_mapping = 0
" }}}

" VIM-PHP-CS-FIXER PLUGIN {{{
if isdirectory(expand("~/.vim/bundle/vim-php-cs-fixer"))
    if !executable('~/php-cs-fixer')
        let g:php_cs_fixer_path = "~/.composer/vendor/bin/php-cs-fixer"
    end

    let g:php_cs_fixer_verbose = 1
endif
" }}}

" VC PLUGIN {{{
if isdirectory(expand("~/.vim/bundle/vc.vim"))
    let g:vc_allow_leader_mappings = 0
    let g:vc_browse_cache_all = 1
    map <silent> <leader>bl  : VCBlame<CR>
    map <silent> <leader>ci  : VCCommit<CR>
    map <silent> <leader>df  : VCDiff<CR>
    map <silent> <leader>dfi : VCDiff!<CR>
    map <silent> <leader>st  : VCStatus<CR>
    map <silent> <leader>su  : VCStatus u<CR>
    map <silent> <leader>sq  : VCStatus u q<CR>
    map <silent> <leader>sc  : VCStatus .<CR>
    map <silent> <leader>lg  : VCLog<CR>
    "map <silent> <leader>b  : VCBrowse<CR>
    "map <silent> <leader>bl : VCBrowseMyList<CR>
    "map <silent> <leader>br : VCBrowseRepo<CR>
    "map <silent> <leader>bw : VCBrowseWorkingCopy<CR>
    "map <silent> <leader>bb : VCBrowseBookMarks<CR>
    "map <silent> <leader>bf : VCBrowseBuffer<CR>
    "map <silent> <leader>bm : VCBrowse<CR>
    map <silent> <leader>q   : diffoff! <CR>: q<CR>
endif
" }}}

" ULTISNIPS PLUGIN {{{
if isdirectory(expand("~/.vim/bundle/ultisnips"))
    let g:UltiSnipsExpandTrigger="<tab>"
    let g:UltiSnipsJumpForwardTrigger="<c-j>"
    let g:UltiSnipsJumpBackwardTrigger="<c-k>"
endif
" }}}

" MATCHIT PLUGIN {{{
runtime! macros/matchit.vim
" }}}

" MULTIPLE CURSORS {{{
if isdirectory(expand("~/.vim/bundle/neocomplete.vim/"))
    " Called once right before you start selecting multiple cursors
    function! Multiple_cursors_before()
        if exists(':NeoCompleteLock')==2
            exe 'NeoCompleteLock'
        endif
    endfunction

    " Called once only when the multiple selection is canceled (default <Esc>)
    function! Multiple_cursors_after()
        if exists(':NeoCompleteUnlock')==2
            exe 'NeoCompleteUnlock'
        endif
    endfunction
endif
" }}}

" TABULARIZE {{{
if isdirectory(expand("~/.vim/bundle/tabular"))
    nmap <Leader>a& :Tabularize /&<CR>
    vmap <Leader>a& :Tabularize /&<CR>
    nmap <Leader>a= :Tabularize /=<CR>
    vmap <Leader>a= :Tabularize /=<CR>
    nmap <Leader>a=> :Tabularize /=><CR>
    vmap <Leader>a=> :Tabularize /=><CR>
    nmap <Leader>a: :Tabularize /:<CR>
    vmap <Leader>a: :Tabularize /:<CR>
    nmap <Leader>a:: :Tabularize /:\zs<CR>
    vmap <Leader>a:: :Tabularize /:\zs<CR>
    nmap <Leader>a, :Tabularize /,<CR>
    vmap <Leader>a, :Tabularize /,<CR>
    nmap <Leader>a,, :Tabularize /,\zs<CR>
    vmap <Leader>a,, :Tabularize /,\zs<CR>
    nmap <Leader>a<Bar> :Tabularize /<Bar><CR>
    vmap <Leader>a<Bar> :Tabularize /<Bar><CR>
endif
" }}}

" NEOCOMPLETE {{{
if isdirectory(expand("~/.vim/bundle/neocomplete.vim/"))
    " augroup neocomplete_enable
    "     autocmd!
    "     autocmd VimEnter * NeoCompleteEnable
    " augroup END
    "
    " values must be set before enabling plugin
    let g:neocomplete#enable_cursor_hold_i              = 1
    let g:neocomplete#cursor_hold_i_time                = 800

    let g:neocomplete#enable_at_startup                 = 1
    let g:neocomplete#sources#tags#cache_limit_size     = 1048576
    let g:neocomplete#enable_smart_case                 = 1
    let g:neocomplete#enable_auto_delimiter             = 1
    let g:neocomplete#max_list                          = 15
    let g:neocomplete#force_overwrite_completefunc      = 1
    let g:neocomplete#sources#syntax#min_keyword_length = 4
    let g:neocomplete#auto_completion_start_length      = 2

    " Define dictionary.
    " let g:neocomplete#sources#dictionary#dictionaries = {
    "             \ 'default' : '',
    "             \ 'vimshell' : $HOME.'/.vimshell_hist',
    "             \ 'scheme' : $HOME.'/.gosh_completions'
    "             \ }

    " Disable automatic completion for each and every typing.
    " We can use ^X^U to trigger this completion.
    " let g:neocomplete#disable_auto_complete = 0

    if !exists('g:neocomplete#keyword_patterns')
        let g:neocomplete#keyword_patterns = {}
    endif

    let g:neocomplete#keyword_patterns['default'] = '\h\w*'

    inoremap <expr><C-g>     neocomplete#undo_completion()
    inoremap <expr><C-l>     neocomplete#complete_common_string()

    " Recommended key-mappings.
    " <CR>: close popup and save indent.
    inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
    function! s:my_cr_function()
        return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
        " For no inserting <CR> key.
        "return pumvisible() ? "\<C-y>" : "\<CR>"
    endfunction

    " <TAB>: completion.
    " inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
    " <C-h>, <BS>: close popup and delete backword char.
    inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"

    " Close popup by <Space>.
    "inoremap <expr><Space> pumvisible() ? "\<C-y>" : "\<Space>"

    " AutoComplPop like behavior.
    "let g:neocomplete#enable_auto_select = 1

    " Shell like behavior(not recommended).
    "set completeopt+=longest
    "let g:neocomplete#enable_auto_select = 1
    "let g:neocomplete#disable_auto_complete = 1
    "inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

    " Enable omni completion.
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

    " Enable heavy omni completion.
    " if !exists('g:neocomplete#force_omni_input_patterns')
    "     let g:neocomplete#sources#omni#input_patterns = {}
    " endif
    "
    if !exists('g:neocomplete#sources#omni#input_patterns')
        let g:neocomplete#sources#omni#input_patterns = {}
    endif
    let g:neocomplete#sources#omni#input_patterns.python = ''
    let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
    let g:neocomplete#sources#omni#input_patterns.typescript = '[^. *\t]\.\w*\|\\w*::'

    "let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
    "let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

endif
" }}}

" VIM-AIRLINE PLUGIN {{{
" Set configuration options for the statusline plugin vim-airline.
" Use the powerline theme and optionally enable powerline symbols.
" To use the symbols , , , , , , and .in the statusline
" See `:echo g:airline_theme_map` for some more choices
" Default in terminal vim is 'dark'
"
" git clone https://github.com/bling/vim-airline ~/.vim/bundle/vim-airline
"
if isdirectory(expand("~/.vim/bundle/vim-airline/"))
    let g:airline_powerline_fonts                    = 1
    let g:airline#extensions#tabline#enabled         = 1
    let g:airline#extensions#tabline#formatter       = 'unique_tail'
    let g:airline#extensions#tabline#left_sep        = ' '
    let g:airline#extensions#tabline#left_alt_sep    = '¦'
    let g:airline#extensions#tabline#buffer_nr_show  = 1

    if !has('gui_running')
        " let g:airline_theme = 'behelit'
        let g:airline_theme = 'badwolf'
    endif

    "let g:airline_left_sep                    = ''
    "let g:airline_right_sep                   = ''
    let g:airline_section_b                   = airline#section#create(['hunks', 'whitespace', '  ', '%{cfi#format(" %s() ", "[No Function]")}'])

    " STATUSAR
    let g:airline_section_warning=airline#section#create(['syntastic', ' ', 'whitespace', ' ', '%{gutentags#statusline()}'])

    if !exists('g:airline_powerline_fonts')
        " Use the default set of separators with a few customizations
        let g:airline_left_sep='›'  " Slightly fancier than '>'
        let g:airline_right_sep='‹' " Slightly fancier than '<'
    endif
endif
" }}}

" INDENTLINE PLUGIN {{{
if isdirectory(expand("~/.vim/bundle/indentLine/"))
    let g:indentLine_enabled = 0
    nnoremap <leader>ii :IndentLinesToggle<CR>
    "let g:indentLine_color_gui = '#A4E57E'
    let g:indentLine_char = '︙'
    let g:indentLine_char = '│'
    let g:indentLine_char = '┆'
endif
" }}}

" ARGWRAP PLUGIN {{{
if isdirectory(expand("~/.vim/bundle/vim-argwrap/"))
    nnoremap <leader>aw :ArgWrap<CR>
endif
" }}}

" SURROUND PLUGIN {{{
if isdirectory(expand("~/.vim/bundle/vim-surround/"))
    function! SurroundIt()
        silent! normal 0f(f cs()
    endfunction

    command! Surround :call SurroundIt()
    nnoremap <leader>sr : Surround<CR>

    nnoremap <leader>cs cs()
    nnoremap <silent> <Plug>Dsurround  :<C-U>call <SID>dosurround("(", ")")<CR>
endif
" }}}

" TYPESCRIPT PLUGIN {{{
if isdirectory(expand("~/.vim/bundle/tsuquyomi"))
    let g:tsuquyomi_disable_quickfix = 1
    let g:tsuquyomi_tsserver_path="$HOME/.npm-packages/bin/tsserver"
endif
" }}}

" VIM-RSI {{{
if isdirectory(expand("~/.vim/bundle/vim-rsi"))
    let g:rsi_no_meta = 1
endif
" }}}

" GREPLACE {{{
if isdirectory(expand("~/.vim/bundle/greplace.vim"))
    set grepprg=ag
    let g:grep_cmd_opts = '--line-numbers --noheading'
endif
" }}}

" VIM THEME PENCIL {{{
let g:airline_theme = 'pencil'
let g:pencil_gutter_color = 1               " 0 - mono (default) / 1 - color
let g:pencil_neutral_code_bg = 1            " 0 - gray (default) / 1 - neutral
let g:pencil_higher_contrast_ui = 0         " 0 - normal (def) / 1 - high contrast
" }}}

" NETRW {{{
"let g:netrw_banner = 0
"let g:netrw_liststyle = 3
"let g:netrw_sortoptions = 'i'
" }}}

" GUTENTAGS {{{
if isdirectory(expand("~/.vim/bundle/vim-gutentags"))
    let g:gutentags_exclude = ['node_modules', 'vendor', 'components']
    let g:gutentags_cache_dir = expand('~/.cache/gutentags')
    let g:gutentags_generate_on_write = 1
    " -> already default settting let g:gutentags_project_root = ['.svn', '.git']
endif
" }}}

" AUTO-PAIRS {{{
if isdirectory(expand("~/.vim/bundle/auto-pairs"))
    let g:AutoPairsFlyMode = 0
    "let g:AutoPairsShortcutBackInsert = '<C-z>'
endif
" }}}

" PDV {{{
if isdirectory(expand("~/.vim/bundle/pdv"))
    let g:pdv_template_dir = $HOME ."/.vim/bundle/pdv/templates_snip"
    nnoremap <buffer> <leader>pk :call pdv#DocumentWithSnip()<CR>
endif
" }}}

" PHPCOMPLETE.VIM {{{
if isdirectory(expand("~/.vim/bundle/phpcomplete.vim"))
    let g:phpcomplete_complete_for_unknown_classes = 1
    let g:phpcomplete_search_tags_for_variables = 1
    let g:phpcomplete_parse_docblock_comments = 1
endif
" }}}

" SUPERTAB {{{
let g:SuperTabDefaultCompletionType = "context"
let g:SuperTabContextDefaultCompletionType ="<C-x><C-o>"
let g:SuperTabRetainCompletionDuration = "completion"
let g:SuperTabCompletionContexts = ['s:ContextText', 's:ContextDiscover']
let g:SuperTabContextTextOmniPrecedence = ['&omnifunc', '&completefunc']
let g:SuperTabContextDiscoverDiscovery = [ "&omnifunc:<c-x><c-o>", "&completefunc:<c-x><c-u>"]
"let g:SuperTabLongestHighlight = 2
"let g:SuperTabClosePreviewOnPopupClose = 1
" }}}
